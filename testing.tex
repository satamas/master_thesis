\chapter{Тестирование}
\section{Тестирование серверного кода}
	Тестирование серверного кода является частью автоматической сборки приложения на TeamCity. Оно производится при помощи библиотеки Junit. В процессе тестирования проверяется что:
\begin{itemize}
\item Сервер корректно транслирует Java код в Котлин
\item Сервер корректно автоматически дополняет код
\item Сервер корректно обнаруживает ошибки в коде.
\item Сервер корректно исполняет код.
\item Сервер выдаёт ошибки при исполнении небезопасного кода.
\item В примерах не содержится ошибок. 
\end{itemize}
	
	Основным преимуществом такого набора тестов является то, что мы можем безопасно обновлять версию Котлина, использующуюся для обработки пользовательских запросов. Также данные тесты проверяют корректность работы приложения при изменении серверного кода.
	
	Для проверки корректности примеров каждый из них подвергается ряду тестов. Во-первых, код примера проверяется сервером на наличие ошибок и предупреждений. Если сервер находит какие-либо ошибки, то это означает, что наш пример устарел из-за обновления Котлина, и необходимо его обновить. Во-вторых, проверяется, что данный пример компилируется и при запуске выдаёт ожидаемый результат. Следует отметить, что такие тесты проверяют не только примеры, но и работоспособность самого сервера. 
	
	Кроме примеров существует ещё ряд тестовых программ, которые  используются для тестирования. При их помощи проверяется ряд особых случаев (использование Kotlin reflection, например), а также то, что мы корректно реагируем на код, который пытается выполнить небезопасные действия.
	
\section{Нагрузочное тестирование}

	Нагрузочное тестирование интернет-приложения -- это проверка его поведения при большом количестве запросов. Такое тестирование позволяет выявить проблемы, возникающие при этом, и оценить максимальное количество пользователей, которое может обслужить данное приложение.
	
	В случае нашего приложения ожидаемым узким местом были запросы на исполнение программы. В рамках нагрузочного тестирования планировалось: 
\begin{itemize}
\item Проверить сервер на наличие других узких мест.
\item Проверить поведение сервера при исполнении особых программ, а именно:
	\begin{itemize}
		\item Исполнение бесконечных программ
		\item Исполнение программ, потребляющих бесконечное количество памяти
		\item Исполнение программ, генерирующих бесконечно большой вывод.
	\end{itemize}
\item Проверить работоспособность автоматического масштабирования
\item Узнать количество пользователей, которые может обслужить одна нода
\item Посмотреть на поведение ноды при подаче на неё большой нагрузки
\end{itemize}

	Всё нагрузочное тестирование проводилось при помощи программы Jmeter.

	Чтобы проверить сервер на наличие узких мест было использовано то, что запросы делятся на несколько типов. Сервер нагружался запросами одного типа, и исследовалось его поведение при этом. Так, например, для проверки внешнего сервера отправлялись запросы на выдачу статического контента и запросы на выдачу примеров.
	
	В результате таких проверок внешнего сервера получились следующие параметры:
\begin{itemize}
	\item 9 заходов новых пользователей в секунду (т.е. 32000 новых заходов в час) (~200MiB/s bandwidth)
	\item 700 запросов на загрузку примера в секунду
\end{itemize}
	Данные параметры являются вполне приемлемыми для нашего приложения, а значит внешний сервер не является узким местом приложения. 
	
	Ещё одним потенциально узким местом приложения является база данных, но, согласно статистике использования нашего приложения, большинство пользователей не авторизуются, а значит и запросы к базе дынных не отправляют.
	
	Это означает, что единственным узким местом нашего приложения являются внутренние сервера, поэтому при оценке производительности системы рассматривались исключительно запросы к внутреннему серверу.

	Для того, чтобы оценить количество пользователей, которое может обслужить наше приложение, необходимо было составить модель поведения пользователя. Это было сделано на основе сохранённых записей об активности пользователей на старом сайте kotlin-demo.jetbrains.com. В результате были созданы две модели пользователя:
\begin{itemize}
	\item Активный пользователь -- 13 запросов на проверку ошибок в минуту, 1 запрос на автодополнение в минуту, 1 запрос на исполнение в минуту.
	\item Усреднённый пользователь -- 4 запроса на проверку ошибок в минуту, 1 запрос на автодополнение в три минуты, 1 запрос на исполнение в три минуты.
\end{itemize}
	
	В результате нагрузочного тестирования внутренних серверов были получены следующие результаты:
	\begin{itemize}
		\item Одна машина:
		\begin{itemize}
			\item максимум 2.75 запросов на исполнение в секунду;
			\item максимум 110 "активных" пользователей в онлайне
			\item максимум 370 "усреднённых" пользователей в онлайне 
		\end{itemize}
		
		\item Предельная нагрузка на всю систему, приблизительная, при 10 запущенных машинах:
		\begin{itemize}
			\item 3500-4000 пользователей в онлайне;
		\end{itemize} 
	\end{itemize}
	Также был обнаружен ряд проблем с памятью, возникающих при исполнении программ, генерирующих бесконечный вывод. Впоследствии данные проблемы были устранены путём введения ограничений на потребляемую память для пользовательских процессов, сервера, а также докер-контейнера, в котором всё исполняется.
	
\section{Тестирование клиентского кода}
	Тестирование клиентского кода является важной частью тестирования и при этом, пожалуй, наиболее сложной частью. Сложность подобного тестирования заключается в том, что
\begin{enumerate}
	\item  Для тестирования клиентского кода необходим запущенный сервер или его имитация.
	\item Клиентский код исполняется в браузере, причём в разных браузерах может наблюдаться  различное исполнение кода.
	\item Для полноценного тестирования необходимо тестировать не только код, но и внешний вид приложения и проверять что он не отличается в различных браузерах.
\end{enumerate}

	На данный момент описанные выше проблемы, по большому счёту, не решены. Имеющееся тестирование клиентского кода заключается в небольшом наборе selenium тестов, которые проверяют корректность подсветки кода, корректность исполнения программ, а также работу с проектами. Данные тесты требуют запущенного сервера и запускаются внутри браузера firefox, что делает невозможным их запуск в процессе автоматической сборки приложения.
	
	В связи с недостатками имеющегося тестирования и, учитывая описанные выше сложности тестирования клиентского кода, сейчас разрабатывается новая система тестов. 
Основой данной системы тестов является программа karma, которая позволяет запускать тесты в различных средах. Это сделает возможным легко запускать тесты на любой машине, т.к. отпадает требование наличия конкретного браузера. Одной из возможных сред является phantomjs, что позволяет запускать тесты на машинах без браузеров вообще, в том числе на агентах сервера сборки приложений. 
	
	